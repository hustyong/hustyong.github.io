<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="限流的作用限流定义：限制「速率」，或从业务层限制「总数」，被限流的请求，直接进入「降级」fallback 流程(fallback与业务相关)； 使用场景：  应对突发流量，避免系统被压垮（全局限流和IP限流）。  防刷，防止机器人脚本等频繁调用服务（userID限流和IP限流）   对于应对突发流量避免系统压垮这个情景，可以在以下几方面做具体限流  业务系统入口(入流量)，比如秒杀活动等系统做限流">
<meta property="og:type" content="article">
<meta property="og:title" content="系统保护-限流">
<meta property="og:url" content="http://example.com/2021/10/17/%E9%99%90%E6%B5%81/index.html">
<meta property="og:site_name" content="hustyong的blog">
<meta property="og:description" content="限流的作用限流定义：限制「速率」，或从业务层限制「总数」，被限流的请求，直接进入「降级」fallback 流程(fallback与业务相关)； 使用场景：  应对突发流量，避免系统被压垮（全局限流和IP限流）。  防刷，防止机器人脚本等频繁调用服务（userID限流和IP限流）   对于应对突发流量避免系统压垮这个情景，可以在以下几方面做具体限流  业务系统入口(入流量)，比如秒杀活动等系统做限流">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-17T06:10:18.000Z">
<meta property="article:modified_time" content="2021-10-17T14:24:23.719Z">
<meta property="article:author" content="hustyong">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="限流">
<meta property="article:tag" content="高可用">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/10/17/%E9%99%90%E6%B5%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>系统保护-限流 | hustyong的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hustyong的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/17/%E9%99%90%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hustyong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hustyong的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          系统保护-限流
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-17 14:10:18 / 修改时间：22:24:23" itemprop="dateCreated datePublished" datetime="2021-10-17T14:10:18+08:00">2021-10-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="限流的作用"><a href="#限流的作用" class="headerlink" title="限流的作用"></a>限流的作用</h1><p><strong>限流定义：</strong>限制「速率」，或从业务层限制「总数」，被限流的请求，直接进入「降级」fallback 流程(fallback与业务相关)；</p>
<p><strong>使用场景：</strong></p>
<ol>
<li><p>应对突发流量，避免系统被压垮（全局限流和IP限流）。</p>
</li>
<li><p>防刷，防止机器人脚本等频繁调用服务（userID限流和IP限流）</p>
</li>
</ol>
<p><strong>对于应对突发流量避免系统压垮这个情景，可以在以下几方面做具体限流</strong></p>
<ol>
<li>业务系统入口(入流量)，比如秒杀活动等系统做限流</li>
<li>系统依赖的外部系统(出流量)，比如某个渠道的支付QPS只有300，我们在访问它的服务对这个渠道做限流(防止雪崩)</li>
<li>核心子系统，比如交易</li>
</ol>
<h1 id="限流的行为"><a href="#限流的行为" class="headerlink" title="限流的行为"></a>限流的行为</h1><p>在接口的请求数达到限流的条件时触发的操作，一般可进行以下行为。</p>
<p>拒绝服务：把多出来的请求拒绝掉</p>
<p>服务降级：关闭或是把后端服务做降级处理。这样可以让服务有足够的资源来处理更多的请求</p>
<p>特权请求：资源不够了，我只能把有限的资源分给重要的用户</p>
<p>延时处理：一般会有一个队列来缓冲大量的请求，这个队列如果满了，那么就只能拒绝用户了，如果这个队列中的任务超时了，也要返回系统繁忙的错误了</p>
<p>弹性伸缩：用自动化运维的方式对相应的服务做自动化的伸缩</p>
<h1 id="单机-amp-分布式"><a href="#单机-amp-分布式" class="headerlink" title="单机&amp;分布式"></a>单机&amp;分布式</h1><p>本质上单机限流和分布式限流的区别其实就在于 “阈值” 存放的位置。单机限流就上面所说的算法直接在单台服务器上实现就好了，而往往我们的服务是集群部署的。因此需要多台机器协同提供限流功能。</p>
<p>单节点限流<br>单实例限流，实现简单；依赖的资源如DB 无法被保护</p>
<p>分布式限流<br>基于某种中间件(Redis)的限流方式，实现较复杂；但是能保护依赖资源不受流量冲击</p>
<h1 id="限流阈值"><a href="#限流阈值" class="headerlink" title="限流阈值"></a>限流阈值</h1><p>限流阈值的设置是一个难点，数值设置大了，超过服务器处理能力导致系统奔溃；数值设置小了，资源利用率无法最大化，并且影响用户体验。</p>
<p>阈值设置，目前思路：</p>
<ol>
<li>上线前进行压测，确认整个业务系统的处理能力</li>
<li>灰度阈值，达到限流阈值时，服务只进行告警，开发和运维确认系统的资源情况，对阈值进行调整或者确认；等到对整个系统的处理能力比较清楚时，在打开开关进行真正的限流。</li>
</ol>
<h1 id="限流实现算法"><a href="#限流实现算法" class="headerlink" title="限流实现算法"></a>限流实现算法</h1><h2 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h2><p>将时间划分为多个窗口，在每个窗口内每有一次请求就将计数器加一；如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</p>
<p>优点：实现简单<br>缺点：不够平滑，并且存在“两倍配置速率”问题。</p>
<p>两倍配置速率”问题：<br>考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求。</p>
<h2 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h2><p>将时间划分为多个区间，在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间。如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</p>
<p>优点：避免双倍突发请求问题；时间区间的精度足够高时可以做到平滑<br>缺点：时间区间的精度越高，算法所需的空间容量就越大；依然存在突刺的情况</p>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>将每个请求视作”水滴”放入”漏桶”进行存储，“漏桶”以固定速率向外”漏”出请求来执行如果”漏桶”空了则停止”漏水”；如果”漏桶”满了则多余的”水滴”会被直接丢弃。</p>
<p>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</p>
<p>优点：解决了突刺现象<br>缺点：当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也得在队列当中等一段时间才能被响应</p>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>令牌以固定速率生成；生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃。当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行；如果桶空了，那么尝试取令牌的请求会被直接丢弃。</p>
<p>优点：既平滑分布，又能够承受范围内的突发请求<br>缺点：每个请求必须从令牌桶取令牌，有性能要求</p>
<h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><h2 id="Golang标准库限流器time-rate"><a href="#Golang标准库限流器time-rate" class="headerlink" title="Golang标准库限流器time/rate"></a>Golang标准库限流器time/rate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// Wait is shorthand for WaitN(ctx, 1).</span><br><span class="line">func (lim *Limiter) Wait(ctx context.Context) (err error) &#123;</span><br><span class="line">    return lim.WaitN(ctx, 1)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// WaitN blocks until lim permits n events to happen.</span><br><span class="line">// It returns an error if n exceeds the Limiter&#x27;s burst size, the Context is</span><br><span class="line">// canceled, or the expected wait time exceeds the Context&#x27;s Deadline.</span><br><span class="line">// The burst limit is ignored if the rate limit is Inf.</span><br><span class="line">func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) &#123;</span><br><span class="line">    lim.mu.Lock()</span><br><span class="line">    burst := lim.burst</span><br><span class="line">    limit := lim.limit</span><br><span class="line">    lim.mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    if n &gt; burst &amp;&amp; limit != Inf &#123;</span><br><span class="line">        return fmt.Errorf(&quot;rate: Wait(n=%d) exceeds limiter&#x27;s burst %d&quot;, n, burst)</span><br><span class="line">    &#125;</span><br><span class="line">    // Check if ctx is already cancelled</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        return ctx.Err()</span><br><span class="line">    default:</span><br><span class="line">    &#125;</span><br><span class="line">    // Determine wait limit</span><br><span class="line">    now := time.Now()</span><br><span class="line">    waitLimit := InfDuration</span><br><span class="line">    if deadline, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">        waitLimit = deadline.Sub(now)</span><br><span class="line">    &#125;</span><br><span class="line">    // Reserve</span><br><span class="line">    r := lim.reserveN(now, n, waitLimit)</span><br><span class="line">    if !r.ok &#123;</span><br><span class="line">        return fmt.Errorf(&quot;rate: Wait(n=%d) would exceed context deadline&quot;, n)</span><br><span class="line">    &#125;</span><br><span class="line">    // Wait if necessary</span><br><span class="line">    delay := r.DelayFrom(now)</span><br><span class="line">    if delay == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    t := time.NewTimer(delay)</span><br><span class="line">    defer t.Stop()</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-t.C:</span><br><span class="line">        // We can proceed.</span><br><span class="line">        return nil</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        // Context was canceled before we could proceed.  Cancel the</span><br><span class="line">        // reservation, which may permit other events to proceed sooner.</span><br><span class="line">        r.Cancel()</span><br><span class="line">        return ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Wait 实际上就是 WaitN(ctx,1)。</p>
<p>​    当使用 WaitN 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 WaitN 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。</p>
<p>​    Wait 方法有一个 context 参数，我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。</p>
<p>​    此方法实现, 并没有单独维护一个 Timer，而是采用了 lazyload 的方式，直到每次消费之前才根据时间差更新 Token 数目，而且也不是用 BlockingQueue 来存放 Token，而是仅仅通过计数的方式。</p>
<h2 id="Uber开源RateLimit"><a href="#Uber开源RateLimit" class="headerlink" title="Uber开源RateLimit"></a>Uber开源RateLimit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//根据初始化限流大小，生成每次请求见的时间间隔perRequest，以及支持的最大松弛量maxSlack</span><br><span class="line">perRequest: time.Second / time.Duration(rate)</span><br><span class="line">maxSlack:   -10 * time.Second / time.Duration(rate)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//last表示上次结束时间， sleepFor表示要等待时间</span><br><span class="line">newState.sleepFor += t.perRequest - now.Sub(oldState.last)</span><br><span class="line">// We shouldn&#x27;t allow sleepFor to get too negative, since it would mean that</span><br><span class="line">// a service that slowed down a lot for a short period of time would get</span><br><span class="line">// a much higher RPS following that.</span><br><span class="line">if newState.sleepFor &lt; t.maxSlack &#123;</span><br><span class="line">    newState.sleepFor = t.maxSlack</span><br><span class="line">&#125;</span><br><span class="line">if newState.sleepFor &gt; 0 &#123;</span><br><span class="line">    newState.last = newState.last.Add(newState.sleepFor)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//sleep</span><br><span class="line">t.clock.Sleep(sleepFor)</span><br></pre></td></tr></table></figure>

<p>uber 在 Github 上开源了一套用于服务限流的 go 语言库 ratelimit, 该组件基于 Leaky Bucket(漏桶)实现，增加了一个maxSlack缓冲，相当于实现了令牌桶, 代码链接：<a target="_blank" rel="noopener" href="https://github.com/golang/time/blob/master/rate/rate.go%E3%80%82">https://github.com/golang/time/blob/master/rate/rate.go。</a></p>
<p>采用原子操作+for的自旋操作来替代lock操作，这样做的目的是减少协程锁竞争。原理上是通过原子操作，计算出此请求需要等待的时间，然后sleep。此方案的劣势是只通过阻塞去限流，在请求量暴增的情况下，会全阻塞住，撑爆服务。可在此方案上增加超量拒绝功能。</p>
<h2 id="redis-lua-实现计数器"><a href="#redis-lua-实现计数器" class="headerlink" title="redis+lua 实现计数器"></a>redis+lua 实现计数器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 获取调用脚本时传入的第一个 key 值（用作限流的 key）</span><br><span class="line">local key = KEYS[1]</span><br><span class="line">-- 获取调用脚本时传入的第一个参数值（限流大小）</span><br><span class="line">local limit = tonumber(ARGV[1])</span><br><span class="line">-- 获取计数器的限速区间 TTL</span><br><span class="line">local ttl = tonumber(ARGV[2])</span><br><span class="line"></span><br><span class="line">-- 获取当前流量大小</span><br><span class="line">local curentLimit = tonumber(redis.call(&#x27;get&#x27;, key) or &quot;0&quot;)</span><br><span class="line"></span><br><span class="line">-- 是否超出限流</span><br><span class="line">if curentLimit + 1 &gt; limit then</span><br><span class="line">    -- 返回 (拒绝)</span><br><span class="line">    return 0</span><br><span class="line">else</span><br><span class="line">    -- 没有超出 value + 1</span><br><span class="line">    redis.call(&#x27;INCRBY&#x27;, key, 1)</span><br><span class="line">    -- 如果 key 中保存的并发计数为 0，说明当前是一个新的时间窗口，它的过期时间设置为窗口的过期时间</span><br><span class="line">    if (curentLimit == 0) then</span><br><span class="line">          redis.call(&#x27;EXPIRE&#x27;, key, ttl)</span><br><span class="line">      end</span><br><span class="line">    -- 返回 (放行)</span><br><span class="line">    return 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 <code>KEYS[1]</code> 获取传入的 key 参数，为某个限流指标的 key</li>
<li>通过 <code>ARGV[1]</code> 获取传入的 limit 参数，为限流值</li>
<li>通过 <code>ARGV[2]</code> 获取限流区间 ttl</li>
<li>通过 <code>redis.call</code>，拿到 key 对应的值（默认为 0），接着与 limit 判断，如果超出表示该被限流；否则，使用 <code>INCRBY</code> 增加 1，未限流（需要处理初始化的情况，设置 <code>TTL</code>）</li>
</ol>
<h2 id="redis-lua-实现令牌"><a href="#redis-lua-实现令牌" class="headerlink" title="redis+lua 实现令牌"></a>redis+lua 实现令牌</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-- 获取调用脚本时传入的第一个key值（用作限流的 key）</span><br><span class="line">local key = KEYS[1]</span><br><span class="line">-- 获取调用脚本时传入的第一个参数值（限流频率）</span><br><span class="line">local rate = tonumber(ARGV[1])</span><br><span class="line">-- 获取调用脚本时传入的第二个参数值（容量大小）</span><br><span class="line">local capacity = tonumber(ARGV[2])</span><br><span class="line">-- 获取调用脚本时传入的第三个参数值（获取token数量）</span><br><span class="line">local needTokenNum = tonumber(ARGV[3])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--计算每次执行所需时间</span><br><span class="line">local perRequest = 1/rate</span><br><span class="line">--此处获取当前时间，这里最好是获取redis服务器机器时间</span><br><span class="line">local now = getNowTime() </span><br><span class="line">--获取最后一次执行时间</span><br><span class="line">local last = tonumber(redis.pcall(&#x27;hget&#x27;, key, &#x27;last&#x27;)) or 0</span><br><span class="line">if last &lt; now - capacity * perRequest then</span><br><span class="line">    last = now - capacity * perRequest</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">--第一个返回值，是否成功获取到token, 0表示成功，1表示失败</span><br><span class="line">local returnResult = 1</span><br><span class="line">--第二个返回值，需要等待的时间，配合第一个返回值，获取token成功时&lt;=0表示不需要等待，&gt;0表示需要等待，返回给app可以让app等待重试</span><br><span class="line">local sleepFor = perRequest * needTokenNum - (now - last)</span><br><span class="line">--sleepFor &gt; 0 表示桶内已无令牌，需要等待</span><br><span class="line">if sleepFor &lt;= 0 then</span><br><span class="line">    last += sleepFor</span><br><span class="line">    returnResult = 0</span><br><span class="line">    redis.pcall(&#x27;hset&#x27;, key, &#x27;last&#x27;, last)</span><br><span class="line">    --redis.pcall(&#x27;hset&#x27;, key, &#x27;rate&#x27;, rate)</span><br><span class="line">    --redis.pcall(&#x27;hset&#x27;, key, &#x27;capacity&#x27;, capacity)</span><br><span class="line">    local expire_t = capacity/rate + 1</span><br><span class="line">    redis.call(&quot;EXPIRE&quot;, key, expire_t)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">return returnResult, sleepFor</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以last作为最好一次执行时间，[last, now]时间区间/perRequest表示桶内剩余令牌数，为负值表示可以立即执行，为正值表示需要等待</p>
<h2 id="python单机限流实现"><a href="#python单机限流实现" class="headerlink" title="python单机限流实现"></a>python单机限流实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">from flask import Flask</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line">capacity = 10  # 桶容量</span><br><span class="line">rate = 1  # 速率 每秒增加一个令牌</span><br><span class="line">last_time = int(time.time())  # 上次访问时间</span><br><span class="line">current_tokens = capacity  # 当前令牌桶中令牌数量</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def can_access():</span><br><span class="line">    global current_tokens</span><br><span class="line">    global last_time</span><br><span class="line"> </span><br><span class="line">    now = int(time.time())</span><br><span class="line">    increase_tokens = (now - last_time) * rate</span><br><span class="line">    current_tokens = min(capacity, current_tokens + increase_tokens)</span><br><span class="line"> </span><br><span class="line">    if current_tokens &gt; 0:</span><br><span class="line">        current_tokens -= 1</span><br><span class="line">        last_time = int(time.time())</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def tokens_bucket():</span><br><span class="line">    if not can_access():</span><br><span class="line">        return &#x27;速率超限制&#x27;</span><br><span class="line">    return &#x27;Hello, 令牌桶!&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<h2 id="redis-python-分布式限流实现-装饰器"><a href="#redis-python-分布式限流实现-装饰器" class="headerlink" title="redis+python 分布式限流实现(装饰器)"></a>redis+python 分布式限流实现(装饰器)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">from flask import Flask</span><br><span class="line">from flask import request</span><br><span class="line">from redis import Redis</span><br><span class="line"> </span><br><span class="line">redis_client = Redis()</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">current_tokens_key = &#x27;current_tokens&#x27;</span><br><span class="line">last_time_key = &#x27;last_time&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def can_access(rate=1, capacity=5):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param rate: 令牌桶添加速率，默认美妙1个</span><br><span class="line">    :param capacity: 令牌桶容量，默认5</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def wrapper(func):</span><br><span class="line">        def inner(*arg, **kwargs):</span><br><span class="line">            func_name = func.__name__</span><br><span class="line">            ip = request.remote_addr</span><br><span class="line">            hash_name = ip + func_name</span><br><span class="line">            now = int(time.time())</span><br><span class="line">            current_tokens = redis_client.hget(hash_name, current_tokens_key)</span><br><span class="line">            last_time = redis_client.hget(hash_name, last_time_key)</span><br><span class="line"> </span><br><span class="line">            current_tokens = int(current_tokens) if current_tokens else capacity</span><br><span class="line">            last_time = int(last_time) if last_time else now</span><br><span class="line"> </span><br><span class="line">            increase_tokens = (now - last_time) * rate  # 增加的令牌桶</span><br><span class="line">            current_tokens = min(capacity, current_tokens + increase_tokens)</span><br><span class="line"> </span><br><span class="line">            if current_tokens &gt; 0:</span><br><span class="line">                redis_client.hset(hash_name, current_tokens_key, current_tokens - 1)</span><br><span class="line">                redis_client.hset(hash_name, last_time_key, int(time.time()))</span><br><span class="line">                return func(*arg, **kwargs)</span><br><span class="line">            else:</span><br><span class="line">                return &#x27;当前ip:&#123;&#125;访问:&#123;&#125;接口速率超限制&#x27;.format(ip, func_name)</span><br><span class="line"> </span><br><span class="line">        return inner</span><br><span class="line"> </span><br><span class="line">    return wrapper</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">@can_access(rate=1, capacity=10)</span><br><span class="line">def tokens_bucket():</span><br><span class="line">    return &#x27;Hello, 令牌桶!&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Django-Ratelimi"><a href="#Django-Ratelimi" class="headerlink" title="Django Ratelimi"></a>Django Ratelimi</h2><p>django-ratelimit :<a target="_blank" rel="noopener" href="https://django-ratelimit.readthedocs.io/en/stable/">https://django-ratelimit.readthedocs.io/en/stable/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># ip 每分钟5次请求，但是 block 请求</span><br><span class="line">@ratelimit(key=&#x27;ip&#x27;, rate=&#x27;5/m&#x27;)</span><br><span class="line">def myview(request):</span><br><span class="line">    # Will be true if the same IP makes more than 5 POST</span><br><span class="line">    # requests/minute.</span><br><span class="line">    was_limited = getattr(request, &#x27;limited&#x27;, False)</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line"># 限制 ip 每分钟5次请求， block 这个请求</span><br><span class="line">@ratelimit(key=&#x27;ip&#x27;, rate=&#x27;5/m&#x27;, block=True)</span><br><span class="line">def myview(request):</span><br><span class="line">    # If the same IP makes &gt;5 reqs/min, will raise Ratelimited</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line"># 限制 post 中有 username 每分钟5次请求，另外请求方法只能为 GET ,POST</span><br><span class="line">@ratelimit(key=&#x27;post:username&#x27;, rate=&#x27;5/m&#x27;, method=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def login(request):</span><br><span class="line">    # If the same username is used &gt;5 times/min, this will be True.</span><br><span class="line">    # The `username` value will come from GET or POST, determined by the</span><br><span class="line">    # request method.</span><br><span class="line">    was_limited = getattr(request, &#x27;limited&#x27;, False)</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line"># 可以使用多种限制</span><br><span class="line">@ratelimit(key=&#x27;post:username&#x27;, rate=&#x27;5/m&#x27;)</span><br><span class="line">@ratelimit(key=&#x27;post:password&#x27;, rate=&#x27;5/m&#x27;)</span><br><span class="line">def login(request):</span><br><span class="line">    # Use multiple keys by stacking decorators.</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line">@ratelimit(key=&#x27;get:q&#x27;, rate=&#x27;5/m&#x27;)</span><br><span class="line">@ratelimit(key=&#x27;post:q&#x27;, rate=&#x27;5/m&#x27;)</span><br><span class="line">def search(request):</span><br><span class="line">    # These two decorators combine to form one rate limit: the same search</span><br><span class="line">    # query can only be tried 5 times a minute, regardless of the request</span><br><span class="line">    # method (GET or POST)</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line">@ratelimit(key=&#x27;ip&#x27;, rate=&#x27;4/h&#x27;)</span><br><span class="line">def slow(request):</span><br><span class="line">    # Allow 4 reqs/hour.</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line"># rate 可以自定义函数</span><br><span class="line">rate = lambda r: None if request.user.is_authenticated() else &#x27;100/h&#x27;</span><br><span class="line">@ratelimit(key=&#x27;ip&#x27;, rate=rate)</span><br><span class="line">def skipif1(request):</span><br><span class="line">    # Only rate limit anonymous requests</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line"># key 可以是 django 的 user ,如果没登录，则使用ip</span><br><span class="line">@ratelimit(key=&#x27;user_or_ip&#x27;, rate=&#x27;10/s&#x27;)</span><br><span class="line">@ratelimit(key=&#x27;user_or_ip&#x27;, rate=&#x27;100/m&#x27;)</span><br><span class="line">def burst_limit(request):</span><br><span class="line">    # Implement a separate burst limit.</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line">@ratelimit(group=&#x27;expensive&#x27;, key=&#x27;user_or_ip&#x27;, rate=&#x27;10/h&#x27;)</span><br><span class="line">def expensive_view_a(request):</span><br><span class="line">    return something_expensive()</span><br><span class="line"></span><br><span class="line">@ratelimit(group=&#x27;expensive&#x27;, key=&#x27;user_or_ip&#x27;, rate=&#x27;10/h&#x27;)</span><br><span class="line">def expensive_view_b(request):</span><br><span class="line">    # Shares a counter with expensive_view_a</span><br><span class="line">    return something_else_expensive()</span><br><span class="line"></span><br><span class="line"># key 可以为 header 里面的值</span><br><span class="line">@ratelimit(key=&#x27;header:x-cluster-client-ip&#x27;)</span><br><span class="line">def post(request):</span><br><span class="line">    # Uses the X-Cluster-Client-IP header value.</span><br><span class="line">    return HttpResponse()</span><br><span class="line"></span><br><span class="line"># key 可以自定义函数</span><br><span class="line">@ratelimit(key=lambda r: r.META.get(&#x27;HTTP_X_CLUSTER_CLIENT_IP&#x27;,</span><br><span class="line">                                    r.META[&#x27;REMOTE_ADDR&#x27;])</span><br><span class="line">def myview(request):</span><br><span class="line">    # Use `X-Cluster-Client-IP` but fall back to REMOTE_ADDR.</span><br><span class="line">    return HttpResponse()</span><br></pre></td></tr></table></figure>
<h1 id="业界限流组件"><a href="#业界限流组件" class="headerlink" title="业界限流组件"></a>业界限流组件</h1><p>Sentinel：阿里开源的限流框架<code> Sentinel</code> 中的匀速排队限流策略，就采用了漏桶算法。</p>
<p>Nginx：Nginx 中的限流模块 <code>limit_req_zone</code>，采用了漏桶算法</p>
<p>Guava客户端限流：Guava是一个客户端组件，在其多线程模块下提供了以RateLimiter为首的几个限流支持类。它只能对“当前”服务进行限流，即它不属于分布式限流的解决方案。</p>
<h1 id="附录-nginx限流"><a href="#附录-nginx限流" class="headerlink" title="附录-nginx限流"></a>附录-nginx限流</h1><p>nginx 限流：限制规则可以多个条件混合使用 (&amp;&amp; 同时满足)</p>
<p>1 nginx 限流  reload 配置就可以<br>2 nginx 可以设置被限流返回码(默认不设置返回503)<br>3 nginx 可以使用prometheus监控(nginx-vts模块，prometheus-lua两种方式进行采集)</p>
<h2 id="请求数限流"><a href="#请求数限流" class="headerlink" title="请求数限流"></a>请求数限流</h2><p>1 限制 单个客户端ip 每秒请求数<br>2 限制 单个host 每秒请求数<br>3 限制 单个url 每秒请求数<br>…</p>
<h2 id="网络连接数限流"><a href="#网络连接数限流" class="headerlink" title="网络连接数限流"></a>网络连接数限流</h2><p>1 限制 单个客户端ip 并发链接数<br>2 限制 单个host 并发链接数<br>3 限制 单个url 并发链接数<br>…</p>
<h2 id="具体配置样例"><a href="#具体配置样例" class="headerlink" title="具体配置样例"></a>具体配置样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">zone：和需要对应的limit_req_zone内存区域名称一致</span><br><span class="line"></span><br><span class="line">burst：可选参数，设置允许突发请求的数量</span><br><span class="line"></span><br><span class="line">nodelay：无延迟排队</span><br><span class="line"></span><br><span class="line">delay：分段限速</span><br><span class="line"></span><br><span class="line">burst、nodelay、delay参数不同的组合可以产生4种限流效果，在下一节限流效果演示中会逐一说明</span><br><span class="line"></span><br><span class="line">指令可以叠加使用，示例中配置了单个ip地址的处理速度，同时限制了整个服务的处理速度</span><br><span class="line"></span><br><span class="line">limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s;</span><br><span class="line">limit_req_zone $server_name zone=perserver:10m rate=10r/s;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_req zone=perip burst=5 nodelay;</span><br><span class="line">    limit_req zone=perserver burst=10;</span><br><span class="line">&#125;</span><br><span class="line">将基本速率限制与其他nginx功能结合使用，可以实现更细微的流量限制，比如搭配geo和map指令可以实现对来自不在“白名单”上的任何人的请求施加速率限制：</span><br><span class="line"></span><br><span class="line">geo $limit &#123;</span><br><span class="line">    default 1;</span><br><span class="line">    10.0.0.0/8 0;</span><br><span class="line">    192.168.0.0/24 0;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">map $limit $limit_key &#123;</span><br><span class="line">    0 &quot;&quot;;</span><br><span class="line">    1 $binary_remote_addr;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">limit_req_zone $limit_key zone=req_zone:10m rate=5r/s;</span><br><span class="line">  </span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        limit_req zone=req_zone burst=10 nodelay;</span><br><span class="line">  </span><br><span class="line">        # ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023552181">https://segmentfault.com/a/1190000023552181</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/ipxnuqwu3lgwxc8j7tzw">https://www.infoq.cn/article/ipxnuqwu3lgwxc8j7tzw</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.bdaily.club/2016/09/29/django-%E9%98%B2%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/">http://blog.bdaily.club/2016/09/29/django-%E9%98%B2%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"># 技术</a>
              <a href="/tags/%E9%99%90%E6%B5%81/" rel="tag"># 限流</a>
              <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag"># 高可用</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/10/17/aboutme/" rel="next" title="关于我">
      关于我 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">限流的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.</span> <span class="nav-text">限流的行为</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E6%9C%BA-amp-%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">单机&amp;分布式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E9%98%88%E5%80%BC"><span class="nav-number">4.</span> <span class="nav-text">限流阈值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">限流实现算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">固定窗口计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">滑动窗口计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%A1%B6"><span class="nav-number">5.3.</span> <span class="nav-text">漏桶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="nav-number">5.4.</span> <span class="nav-text">令牌桶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">6.</span> <span class="nav-text">实现方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Golang%E6%A0%87%E5%87%86%E5%BA%93%E9%99%90%E6%B5%81%E5%99%A8time-rate"><span class="nav-number">6.1.</span> <span class="nav-text">Golang标准库限流器time&#x2F;rate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Uber%E5%BC%80%E6%BA%90RateLimit"><span class="nav-number">6.2.</span> <span class="nav-text">Uber开源RateLimit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-lua-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">redis+lua 实现计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-lua-%E5%AE%9E%E7%8E%B0%E4%BB%A4%E7%89%8C"><span class="nav-number">6.4.</span> <span class="nav-text">redis+lua 实现令牌</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.5.</span> <span class="nav-text">python单机限流实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-python-%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">6.6.</span> <span class="nav-text">redis+python 分布式限流实现(装饰器)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Django-Ratelimi"><span class="nav-number">6.7.</span> <span class="nav-text">Django Ratelimi</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%9A%E7%95%8C%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text">业界限流组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95-nginx%E9%99%90%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">附录-nginx限流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="nav-number">8.1.</span> <span class="nav-text">请求数限流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%99%90%E6%B5%81"><span class="nav-number">8.2.</span> <span class="nav-text">网络连接数限流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E6%A0%B7%E4%BE%8B"><span class="nav-number">8.3.</span> <span class="nav-text">具体配置样例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">9.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hustyong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hustyong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
